[{"title":"单细胞scRNA-seq分析思路总结","date":"2025-09-19T11:09:47.000Z","url":"/myblog.github.io/posts/%E5%8D%95%E7%BB%86%E8%83%9EscRNA-seq%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/","tags":[["单细胞","/myblog.github.io/tags/%E5%8D%95%E7%BB%86%E8%83%9E/"],["scRNA-seq","/myblog.github.io/tags/scRNA-seq/"]],"categories":[["undefined",""]],"content":"单细胞分析思路，把常见的步骤和逻辑框架讲清楚。这里主要以 单细胞转录组（scRNA-seq） 为例。 具体流程 1. 数据准备与质控 (QC) 输入：原始 UMI/reads 矩阵（细胞 × 基因）。 目标：筛掉低质量细胞，保证分析结果可靠。 常见 QC 指标： 每个细胞的总 reads/UMI 数（低了可能是坏细胞，高了可能是双细胞 doublet）。 检测到的基因数。 线粒体基因比例（过高说明细胞可能坏死）。 操作： subset、filter 去掉异常细胞。 DoubletFinder / Scrublet 识别双细胞。 具体方法 2. 标准化与特征选择 归一化 (Normalize)： LogNormalize：每个细胞的 counts 除以总数 × scale.factor，再 log1p。 标准化意义 消除文库大小差异 每个细胞的表达量变成“相对表达”，能直接比较不同细胞。 突出生物差异 高表达的基因被 log 压缩，不至于主导后续分析； 中低表达的差异会更明显，利于发现 marker 基因。 为下游分析提供可比性输入 PCA、聚类、UMAP 等方法都需要输入可比较的数值矩阵。 LogNormalize 后的矩阵能让算法真正捕捉生物学差异，而不是技术噪音。 高变基因选择 (FindVariableFeatures)： 找出在细胞间变异度最高的一批基因（常用 2000）。 具体方法 🔬 Seurat 内置的三种方法 在 FindVariableFeatures() 里可以设置 selection.method： &quot;vst&quot;（Variance Stabilizing Transformation）👉 默认、推荐 思路： 对每个基因，在所有细胞里的表达做方差估计； 把方差和均值之间的关系建模（负二项分布近似）； 计算残差方差（observed variance / expected variance）。 特点： 在去除了均值依赖性后，能稳健地挑出高变基因； 对高表达基因不会过度偏向； 推荐作为大多数 scRNA-seq 分析的标准方法。 &quot;mean.var.plot&quot;（MVP，均值-方差图方法） 思路： 把基因按均值分成 bins； 计算每个基因在 bin 内的 z-score（方差相对 bin 内基因的偏高程度）； 取方差最高的一批基因。 特点： 方法简单直观，可以画图展示（Mean-Variance Plot）。 对噪音和批次效应敏感，不如 vst 稳健。 &quot;dispersion&quot;（离散度方法） 思路： 类似于 MVP，但直接用 标准化后的方差/均值比（dispersion） 来挑基因。 特点： 速度快； 但容易偏向于低均值、相对离散度高的基因。 缩放 (ScaleData)： Z-score 标准化基因表达，用于 PCA 等。 what is Z-score Z-score（标准分数、标准化值）是统计学里常用的一个指标，表示一个数值偏离平均值多少个标准差。 公式： z=x−μσz=\\frac{x−μ}{σ} z=σx−μ​ x：某个观测值 μ：总体/样本的平均值 σ：总体/样本的标准差 在单细胞分析里的应用 在 高变基因筛选（mean.var.plot 方法） 中，Seurat 会把基因按表达均值分成 bins： 先算每个基因的方差； 再和同 bin 内的基因比较，用 z-score 标准化，得到它在该均值水平下是否“比平均更离散”。 高 z-score → 说明这个基因在同水平基因里“更变异”，可能是高变基因。 z-score 就是“标准化的偏离程度”，告诉你一个值比均值高/低了多少个标准差。 在单细胞分析里，它常被用来比较基因在不同均值水平下的方差是否异常高，从而识别高变基因。 3. 降维 线性降维 (PCA)： 提取主要变异维度。 非线性降维 (UMAP/tSNE)： 用于可视化，把高维数据投射到 2D/3D。 4. 邻居图构建与聚类 FindNeighbors：构建 kNN 图或 SNN 图。 FindClusters：基于图的社区检测算法（Louvain/Leiden），得到细胞簇。 意义：把表达相似的细胞归为一群。 5. 细胞类型注释 找 marker 基因 (FindAllMarkers)：每个 cluster 的特异表达基因。 对照已知 marker：推断 cluster 对应的细胞类型。 可选：用参考数据库或自动化工具（SingleR, CellTypist）。 6. 下游分析 根据研究问题不同，可能包括： 差异表达分析 (FindMarkers)：比较不同 cluster / 条件下的基因表达差异。 轨迹推断 (pseudotime)：Monocle/Slingshot 分析发育或分化轨迹。 细胞通讯 (CellChat, CellPhoneDB)：预测细胞间配体-受体相互作用。 基因调控网络 (SCENIC, pySCENIC)：推断转录因子活性。 多组学整合 (WNN, MOFA+, Seurat v5)：整合 RNA、ATAC、ADT 等。 7. 可视化与验证 UMAP/tSNE 图上展示 cluster/marker 表达。 小提琴图、热图展示基因表达模式。 对关键结果做实验验证（qPCR, FISH, flow cytometry）。 ✅ 一句话总结 单细胞分析思路 = 质控 → 归一化 → 特征选择 → 降维 → 构图聚类 → 注释 → 下游分析（差异、轨迹、通讯等）。 它的核心是把高维 noisy 的单细胞数据，通过降维和聚类整理成有生物学意义的细胞群体，然后结合 marker/功能信息解读"},{"title":"github 部署hexo静态博客","date":"2025-09-19T07:22:56.000Z","url":"/myblog.github.io/posts/github-%E9%83%A8%E7%BD%B2hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","tags":[["记录","/myblog.github.io/tags/%E8%AE%B0%E5%BD%95/"],["hexo","/myblog.github.io/tags/hexo/"]],"categories":[["undefined",""]],"content":" 部署hexo到Github 一、创建github项目仓库 在github页面创建一个自己的仓库，这个应该没啥问题 然后拉取远程仓库（我这边用的是kratos rebirth的模板，以下以此模板为例） 修改完配置后用hexo进行部署 注意：在部署的时候分支与修改格式内容的分支尽量重命名，以免后期发生git merge事件！！！ 二、之后就是hexo的部署 然后就完成部署了 更新： 尝试部署到cloudflare上，但是发现静态文件的路径不可用，部署上的网页无法渲染，遂修改静态资源路径，重新开设了一个分支cloudflare，但是后来发现要更新2次就放弃了。。。"},{"title":"记录一下使用kratos模板创建个人博客","date":"2025-09-18T09:03:28.000Z","url":"/myblog.github.io/posts/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8kratos%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":[["记录","/myblog.github.io/tags/%E8%AE%B0%E5%BD%95/"],["kratos","/myblog.github.io/tags/kratos/"]],"categories":[["new!","/myblog.github.io/categories/new/"]],"content":" 记录一下使用kratos模板创建个人博客 以下是用于美化的css文件 花了一个下午研究这玩意，而且在一些奇怪的地方有BUG。 最终成果如图： 于2025年9月18日17:01:49，NJU"},{"date":"2025-09-19T08:57:45.003Z","url":"/myblog.github.io/comments/gitalk.css","categories":[["undefined",""]],"content":".gt-counts, .gt-header-textarea, .gt-user-name { color: var(--kr-theme-text) !important; } .gt-header-textarea, .gt-header-preview, .gt-btn-preview, .gt-comment-content{ border-radius: 15px; } .gt-popup { background-color: var(--kr-theme-page-bg) !important; } .gt-popup { border-color: #6190e8 !important; }"},{"date":"2025-09-19T08:20:54.524Z","url":"/myblog.github.io/comments/gitalk.js","categories":[["undefined",""]],"content":"(() => { const loadComments = async () => { if (typeof Gitalk === \"undefined\") { setTimeout(loadComments, 100); } else { const container = document.getElementById('gitalk-container'); if (!container) { return; } const path = container.getAttribute(\"data-path\"); const gitalk = new Gitalk(Object.assign({ // id: path, // 直接使用路径作为 id id: container.getAttribute(\"data-path-hash\"), // 使用 hash 作为 ID path: path, }, { clientID: 'Ov23liEPcwPsUXR6o3wk', clientSecret: 'c10c8e0b8605cbbb07977c874a7b628938d8bc87', repo: \"myblog.github.io\", owner: \"Hyperion1230\", admin: [\"Hyperion1230\"], distractionFreeMode: false, })); gitalk.render('gitalk-container'); } }; window.loadComments = loadComments; window.addEventListener('pjax:success', () => { window.loadComments = loadComments; }); })();"},{"date":"2025-09-19T08:58:08.340Z","url":"/myblog.github.io/css/custom.css","categories":[["undefined",""]],"content":"/* 修改导航栏背景色 */ .kratos-topnav { background: #085c0999 !important; justify-content: center; height: 80px; } .sf-menu { display: flex; justify-content: center; } /* 悬停高亮效果 */ /* 移除导航菜单悬停效果 */ /* 移除导航菜单悬停效果 */ /* 调整导航字体大小和间距 */ #kratos-menu-wrap .sf-menu a { color: #ffffff; /* text-shadow: 0 0 10px #000000, 0 0 20px #000000, 0 0 30px #000000; */ margin: 10px 10px; font-size: 20px; } #kratos-menu-wrap .sf-menu a { border: 2px solid #090909; background-color: #d4d4d499; border-radius: 15px; } #kratos-desktop-topnav .sf-menu>li>ul.sub-menu a { color: #000000; } .kratos-entry-footer .footer-tag a { color: #000000; background-color: #ffffff; border-radius: 15px; } #kratos-widget-area .widget.widget-kratos-about{ padding-left: 0; padding-right: 0; padding-top: 0; border-radius: 15px } #kratos-widget-area .widget:last-child { border-radius: 15px; } .kratos-entry-border .kratos-entry-post-meta { border-radius: 15px; } #kratos-blog-post .row article{ border-radius: 15px; } #kratos-desktop-topnav .sf-menu>li>ul.sub-menu li a { font-size: 15px; margin-left: auto; margin-right: auto; text-align: center; } #kratos-desktop-topnav .sf-menu>li>ul.sub-menu{ left:0px; } .kratos-hentry, .navigation div, #kratos-widget-area .widget{ border-radius: 15px; } .kr-comments { border-radius: 15px; }"}]